// Code generated by generator; DO NOT EDIT.

//go:generate goqu-crud-gen -model User -table user -dialect mysql -path . -rename-with-tran WithTran
package example2

import (
	"context"
	"fmt"
	"github.com/doug-martin/goqu/v9"
	_ "github.com/doug-martin/goqu/v9/dialect/mysql" // import is need for proper dialect selection
	"github.com/doug-martin/goqu/v9/exp"
	. "github.com/funvit/goqu-crud-gen"
	"github.com/jmoiron/sqlx"
	"time"
)

type (
	// UserRepo implements repository for User.
	UserRepo struct {
		dsn         string
		db          *sqlx.DB
		dialect     goqu.DialectWrapper
		dialectName string
		options     RepositoryOpt

		// short for "table"
		t string
		// short for "table fields"
		f userRepoFields
	}
	userRepoFields struct {
		Id    exp.IdentifierExpression
		Name  exp.IdentifierExpression
		Email exp.IdentifierExpression
	}
)

// PK returns primary key column identifier.
func (s *userRepoFields) PK() exp.IdentifierExpression {
	return s.Id
}

// NewUserRepo returns a new UserRepo.
//
// Note: dont forget to set max open connections and max lifetime.
func NewUserRepo(dsn string, opt ...RepositoryOption) *UserRepo {
	const t = "user"

	s := &UserRepo{
		dsn:         dsn,
		dialect:     goqu.Dialect("mysql"),
		dialectName: "mysql",
		t:           t,
		f: userRepoFields{
			Id:    goqu.C("id").Table(t),
			Name:  goqu.C("name").Table(t),
			Email: goqu.C("email").Table(t),
		},
		options: RepositoryOpt{
			TxGetter: GetTxFromContext,
		},
	}

	for _, o := range opt {
		o(&s.options)
	}

	return s
}

// Connect connects to database instance.
// Must be called after NewUserRepo and before any repo methods.
func (s *UserRepo) Connect(wait time.Duration) error {
	db, err := sqlx.Open(s.dialectName, s.dsn)
	if err != nil {
		return err
	}

	pCtx, pCancel := context.WithTimeout(context.Background(), wait)
	defer pCancel()
	err = db.PingContext(pCtx)
	if err != nil {
		return fmt.Errorf("ping error: %w", err)
	}

	s.db = db

	return nil
}

// SetMaxIdleConns sets the maximum number of connections in the idle
// connection pool.
//
// Note: can helps with stale connections if set (ex: 1 minute).
//
// See also: sql.SetMaxIdleConns.
func (s *UserRepo) SetMaxIdleConns(n int) {
	s.db.SetMaxIdleConns(n)
}

// SetMaxOpenConns sets the maximum number of open connections to the database.
//
// See also: sql.SetMaxOpenConns.
func (s *UserRepo) SetMaxOpenConns(n int) {
	s.db.SetMaxOpenConns(n)
}

// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
//
// See also: sql.SetConnMaxLifetime.
func (s *UserRepo) SetConnMaxLifetime(d time.Duration) {
	s.db.SetConnMaxLifetime(d)
}

// WithTran wraps function call in transaction.
func (s *UserRepo) WithTran(ctx context.Context, f func(ctx context.Context) error) error {
	return Transaction(ctx, s.db, f)
}

func (s *UserRepo) getTxFromContext(ctx context.Context) (*sqlx.Tx, error) {
	return s.options.TxGetter(ctx)
}

// Create creates a new row in database by specified model.
//
// If model have "auto" primary key field - it's will be updated in-place.
func (s *UserRepo) Create(ctx context.Context, m *User) error {

	tx, err := s.getTxFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Insert(s.t).Rows(m).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder error: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("insert query error: %w", err)
	}
	_ = res

	m.Id, err = res.LastInsertId()
	if err != nil {
		return fmt.Errorf("auto id get error: %w", err)
	}

	return nil
}

// iter iterates other select with specified filter(s).
//
// Can be used in your custom query methods.
func (s *UserRepo) iter(
	ctx context.Context,
	filter goqu.Expression,
	f func(m User, stop func()),
	opt ...Option,
) error {

	tx, err := s.getTxFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.From(s.t).Prepared(true)

	if filter != nil {
		ds = ds.Where(filter)
	}

	for _, o := range opt {
		o(ds)
	}

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder error: %w", err)
	}

	sigCtx, sigCtxCancel := context.WithCancel(ctx)
	defer sigCtxCancel()

	rows, err := tx.QueryxContext(ctx, q, args...)
	if err != nil {
		return fmt.Errorf("select query error: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	// todo: check is it safe to declare var here (not in loop)
	var m User
	for rows.Next() {
		select {
		case <-sigCtx.Done():
			break
		default:
		}

		err = rows.StructScan(&m)
		if err != nil {
			return fmt.Errorf("row scan error: %w", err)
		}

		f(m, func() { sigCtxCancel() })
	}

	return nil
}

// each calls wide select.
//
// Can be used in your custom query methods, for example in All.
//
// See also: iter.
func (s *UserRepo) each(ctx context.Context, f func(m User)) error {

	return s.iter(
		ctx,
		nil,
		func(m User, _ func()) {
			f(m)
		},
	)
}

// Get gets model from database.
//
// Note: returns (nil, nil) if row not found.
func (s *UserRepo) Get(ctx context.Context, id int64, opt ...Option) (*User, error) {

	var r *User
	err := s.iter(
		ctx,
		s.f.PK().Eq(id),
		func(m User, stop func()) {
			r = &m
			stop()
		},
		opt...,
	)
	if err != nil {
		return nil, err
	}

	return r, nil
}

func (s *UserRepo) GetManySlice(ctx context.Context, ids []int64, opt ...Option) ([]User, error) {
	items := make([]User, 0, len(ids))

	err := s.iter(
		ctx,
		s.f.PK().In(ids),
		func(m User, _ func()) {
			items = append(items, m)
		},
		opt...,
	)
	if err != nil {
		return nil, err
	}

	return items, nil
}

// Update updates database row by model.
func (s *UserRepo) Update(ctx context.Context, m User) error {

	tx, err := s.getTxFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Update(s.t).
		Prepared(true).
		Set(m).
		Where(s.f.PK().Eq(m.Id))

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder error: %w", err)
	}

	_, err = tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("update query error: %w", err)
	}

	return nil
}

// Delete deletes row by id.
//
// Note: returns amount of deleted rows (expected to be max of 1).
//
// See also: DeleteMany.
func (s *UserRepo) Delete(ctx context.Context, id int64) (n int64, err error) {

	tx, err := s.getTxFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().Eq(id)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder error: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("delete query error: %w", err)
	}

	return res.RowsAffected()
}

// DeleteMany deletes rows by ids.
//
// Warning: be careful with large ids arg.
//
// Note: returns amount of deleted rows.
//
// See also: Delete.
func (s *UserRepo) DeleteMany(ctx context.Context, ids []int64) (n int64, err error) {

	if len(ids) == 0 {
		// noop
		return 0, nil
	}

	tx, err := s.getTxFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().In(ids)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder error: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("delete query error: %w", err)
	}

	return res.RowsAffected()
}

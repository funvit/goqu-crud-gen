// Code generated by generator; DO NOT EDIT.

package mysql

import (
	"context"
	"fmt"
	"github.com/doug-martin/goqu/v9"
	_ "github.com/doug-martin/goqu/v9/dialect/mysql" // import is need for proper dialect selection
	"github.com/doug-martin/goqu/v9/exp"
	. "github.com/funvit/goqu-crud-gen"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"time"
)

type (
	// AccountRepo implements repository for Account.
	AccountRepo struct {
		dsn         string
		db          *sqlx.DB
		dialect     goqu.DialectWrapper
		dialectName string
		options     RepositoryOpt

		// Short for "table".
		t string
		// Short for "table fields", holds repository model fields as goqu exp.IdentifierExpression.
		f accountRepoFields
		// Short for "table columns", holds repository model columns as string.
		//
		// Helps to write goqu.UpdateDataset with goqu.Record{}.
		c accountRepoColumns
	}
	accountRepoFields struct {
		UserId       exp.IdentifierExpression
		Login        exp.IdentifierExpression
		PasswordHash exp.IdentifierExpression
	}
	accountRepoColumns struct {
		UserId       string
		Login        string
		PasswordHash string
	}
)

// NewAccountRepo returns a new AccountRepo.
//
// Note: do not forget to set max open connections and max lifetime.
func NewAccountRepo(dsn string, opt ...RepositoryOption) *AccountRepo {
	const t = "account"

	s := &AccountRepo{
		dsn:         dsn,
		dialect:     goqu.Dialect("mysql"),
		dialectName: "mysql",
		t:           t,
		f: accountRepoFields{
			UserId:       goqu.C("user_id").Table(t),
			Login:        goqu.C("login").Table(t),
			PasswordHash: goqu.C("pass").Table(t),
		},
		c: accountRepoColumns{
			UserId:       "user_id",
			Login:        "login",
			PasswordHash: "pass",
		},
	}
	s.options.CtxTran = &StdCtxTran{
		DB: s.db,
	}

	for _, o := range opt {
		o(&s.options)
	}

	return s
}

// AccountRepoWithInstance returns a new AccountRepo with specified sqlx.DB instance.
func AccountRepoWithInstance(inst *sqlx.DB, opt ...RepositoryOption) *AccountRepo {

	const t = "account"

	s := &AccountRepo{
		dsn:         "",
		db:          inst,
		dialect:     goqu.Dialect("mysql"),
		dialectName: "mysql",
		t:           t,
		f: accountRepoFields{
			UserId:       goqu.C("user_id").Table(t),
			Login:        goqu.C("login").Table(t),
			PasswordHash: goqu.C("pass").Table(t),
		},
		c: accountRepoColumns{
			UserId:       "user_id",
			Login:        "login",
			PasswordHash: "pass",
		},
	}
	s.options.CtxTran = &StdCtxTran{
		DB: s.db,
	}

	for _, o := range opt {
		o(&s.options)
	}

	return s
}

// PK returns primary key column identifier.
func (s *accountRepoFields) PK() exp.IdentifierExpression {
	return s.UserId
}

// Connect connects to database instance.
// Must be called after NewAccountRepo and before any repo methods.
func (s *AccountRepo) Connect(wait time.Duration) error {

	if s.dsn != "" {
		db, err := sqlx.Open(s.dialectName, s.dsn)
		if err != nil {
			return err
		}
		s.db = db
	}

	pCtx, pCancel := context.WithTimeout(context.Background(), wait)
	defer pCancel()

	err := s.db.PingContext(pCtx)
	if err != nil {
		return fmt.Errorf("ping error: %w", err)
	}

	if v, ok := s.options.CtxTran.(*StdCtxTran); ok && v.DB == nil {
		v.DB = s.db
	}

	return nil
}

// SetMaxIdleConns sets the maximum number of connections in the idle
// connection pool.
//
// Note: can helps with stale connections if set (ex: 1 minute).
//
// See also: sql.SetMaxIdleConns.
func (s *AccountRepo) SetMaxIdleConns(n int) {
	s.db.SetMaxIdleConns(n)
}

// SetMaxOpenConns sets the maximum number of open connections to the database.
//
// See also: sql.SetMaxOpenConns.
func (s *AccountRepo) SetMaxOpenConns(n int) {
	s.db.SetMaxOpenConns(n)
}

// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
//
// See also: sql.SetConnMaxLifetime.
func (s *AccountRepo) SetConnMaxLifetime(d time.Duration) {
	s.db.SetConnMaxLifetime(d)
}

// WithTran wraps function call in transaction.
func (s *AccountRepo) WithTran(ctx context.Context, f func(ctx context.Context) error) error {

	return Transaction(ctx, s.db, s.options.CtxTran, f)
}

// Each query must executed within transaction. This method gets
// transaction from context, so exists transaction can be used.
func (s *AccountRepo) txFromContext(ctx context.Context) (*sqlx.Tx, error) {

	return s.options.CtxTran.TxFromContext(ctx)
}

// Create creates a new row in database by specified model.
//
// If model have "auto" primary key field - it's will be updated in-place.
func (s *AccountRepo) Create(ctx context.Context, m *Account) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Insert(s.t).Rows(m).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("tx: exec: %w", err)
	}
	_ = res

	return nil
}

// iter iterates other select.
//
// Can be used in your custom query methods.
//
// Filters, limit or order can be set via opts.
func (s *AccountRepo) iter(
	ctx context.Context,
	fn func(m Account) error,
	opt ...Option,
) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.From(s.t).Prepared(true)

	for _, o := range opt {
		o(ds)
	}

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	sigCtx, sigCtxCancel := context.WithCancel(ctx)
	defer sigCtxCancel()

	rows, err := tx.QueryxContext(sigCtx, q, args...)
	if err != nil {
		return fmt.Errorf("tx: query rows: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	for rows.Next() {
		var m Account

		err = ctx.Err()
		if err != nil {
			return fmt.Errorf("rows: next: %w", err)
		}

		err = rows.StructScan(&m)
		if err != nil {
			return fmt.Errorf("rows struct scan: %w", err)
		}

		err = fn(m)
		if err != nil {
			sigCtxCancel()
			return fmt.Errorf("fn call: %w", err)
		}
	}

	return nil
}

// iterPrimaryKeys iterates other select with specified filter(s).
//
// Can be used in your custom query methods.
//
// Filters, limit or order can be set via opts.
func (s *AccountRepo) iterPrimaryKeys(
	ctx context.Context,
	fn func(pk interface{}) error,
	opt ...Option,
) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.From(s.t).Prepared(true).Select(s.f.PK())

	for _, o := range opt {
		o(ds)
	}

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	sigCtx, sigCtxCancel := context.WithCancel(ctx)
	defer sigCtxCancel()

	rows, err := tx.QueryxContext(sigCtx, q, args...)
	if err != nil {
		return fmt.Errorf("tx: query rows: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	for rows.Next() {
		var pk interface{}

		err = ctx.Err()
		if err != nil {
			return fmt.Errorf("rows: next: %w", err)
		}

		err = rows.Scan(&pk)
		if err != nil {
			return fmt.Errorf("row scan: %w", err)
		}

		err = fn(pk)
		if err != nil {
			sigCtxCancel()
			_ = rows.Close()
			return fmt.Errorf("fn call: %w", err)
		}
	}

	return nil
}

// Get gets model from database.
//
// Note: returns (nil, nil) if row not found.
//
// See also: GetForUpdate.
func (s *AccountRepo) Get(ctx context.Context, id uuid.UUID) (*Account, error) {

	var r *Account

	opts := []Option{
		WithFilter(s.f.PK().Eq(id)),
	}

	err := s.iter(
		ctx,
		func(m Account) error {
			// note: expected to be called once.
			r = &m
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return r, nil
}

// GetForUpdate gets model from database for update (i.e. locks row).
//
// Note: returns (nil, nil) if row not found.
//
// See also: Get.
func (s *AccountRepo) GetForUpdate(ctx context.Context, id uuid.UUID) (*Account, error) {

	var r *Account

	opts := []Option{
		WithFilter(s.f.PK().Eq(id)),
		WithLockForUpdate(),
	}

	err := s.iter(
		ctx,
		func(m Account) error {
			// note: expected to be called once.
			r = &m
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return r, nil
}

// GetMany gets models from database.
//
// See also: GetManyForUpdate.
func (s *AccountRepo) GetMany(ctx context.Context, ids []uuid.UUID) ([]Account, error) {

	items := make([]Account, 0, len(ids))

	opts := []Option{
		WithFilter(s.f.PK().In(ids)),
	}

	err := s.iter(
		ctx,
		func(m Account) error {
			items = append(items, m)
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return items, nil
}

// GetManyForUpdate gets models from database for update (i.e. locks rows).
//
// See also: GetMany.
func (s *AccountRepo) GetManyForUpdate(ctx context.Context, ids []uuid.UUID) ([]Account, error) {

	items := make([]Account, 0, len(ids))

	opts := []Option{
		WithFilter(s.f.PK().In(ids)),
		WithLockForUpdate(),
	}

	err := s.iter(
		ctx,
		func(m Account) error {
			items = append(items, m)
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return items, nil
}

// Update updates database row by model.
func (s *AccountRepo) Update(ctx context.Context, m Account) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Update(s.t).
		Prepared(true).
		Set(m).
		Where(s.f.PK().Eq(m.UserId))

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	_, err = tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("tx: exec: %w", err)
	}

	return nil
}

// Delete deletes row by id.
//
// Note: returns amount of deleted rows (expected to be max of 1).
//
// See also: DeleteMany.
func (s *AccountRepo) Delete(ctx context.Context, id uuid.UUID) (n int64, err error) {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().Eq(id)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder: to sql: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("tx: exec query: %w", err)
	}

	return res.RowsAffected()
}

// DeleteMany deletes rows by ids.
//
// Warning: be careful with large ids arg.
//
// Note: returns amount of deleted rows.
//
// See also: Delete.
func (s *AccountRepo) DeleteMany(ctx context.Context, ids []uuid.UUID) (n int64, err error) {

	if len(ids) == 0 {
		// noop
		return 0, nil
	}

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().In(ids)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder: to sql: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("tx: exec: %w", err)
	}

	return res.RowsAffected()
}

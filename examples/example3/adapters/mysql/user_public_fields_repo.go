// Code generated by generator; DO NOT EDIT.

package mysql

import (
	"context"
	"fmt"
	"github.com/doug-martin/goqu/v9"
	_ "github.com/doug-martin/goqu/v9/dialect/mysql" // import is need for proper dialect selection
	"github.com/doug-martin/goqu/v9/exp"
	. "github.com/funvit/goqu-crud-gen"
	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"time"
)

type (
	// UserPublicFieldsRepo implements repository for UserPublicFields.
	UserPublicFieldsRepo struct {
		dsn         string
		db          *sqlx.DB
		dialect     goqu.DialectWrapper
		dialectName string
		options     RepositoryOpt

		// Short for "table".
		t string
		// Short for "table fields", holds repository model fields as goqu exp.IdentifierExpression.
		f userPublicFieldsRepoFields
		// Short for "table columns", holds repository model columns as string.
		//
		// Helps to write goqu.UpdateDataset with goqu.Record{}.
		c userPublicFieldsRepoColumns
	}
	userPublicFieldsRepoFields struct {
		Id   exp.IdentifierExpression
		Name exp.IdentifierExpression
	}
	userPublicFieldsRepoColumns struct {
		Id   string
		Name string
	}
)

// NewUserPublicFieldsRepo returns a new UserPublicFieldsRepo.
//
// Note: do not forget to set max open connections and max lifetime.
func NewUserPublicFieldsRepo(dsn string, opt ...RepositoryOption) *UserPublicFieldsRepo {
	const t = "user"

	s := &UserPublicFieldsRepo{
		dsn:         dsn,
		dialect:     goqu.Dialect("mysql"),
		dialectName: "mysql",
		t:           t,
		f: userPublicFieldsRepoFields{
			Id:   goqu.C("id").Table(t),
			Name: goqu.C("name").Table(t),
		},
		c: userPublicFieldsRepoColumns{
			Id:   "id",
			Name: "name",
		},
	}
	s.options.CtxTran = &StdCtxTran{
		DB: s.db,
	}

	for _, o := range opt {
		o(&s.options)
	}

	return s
}

// UserPublicFieldsRepoWithInstance returns a new UserPublicFieldsRepo with specified sqlx.DB instance.
func UserPublicFieldsRepoWithInstance(inst *sqlx.DB, opt ...RepositoryOption) *UserPublicFieldsRepo {

	const t = "user"

	s := &UserPublicFieldsRepo{
		dsn:         "",
		db:          inst,
		dialect:     goqu.Dialect("mysql"),
		dialectName: "mysql",
		t:           t,
		f: userPublicFieldsRepoFields{
			Id:   goqu.C("id").Table(t),
			Name: goqu.C("name").Table(t),
		},
		c: userPublicFieldsRepoColumns{
			Id:   "id",
			Name: "name",
		},
	}
	s.options.CtxTran = &StdCtxTran{
		DB: s.db,
	}

	for _, o := range opt {
		o(&s.options)
	}

	return s
}

// PK returns primary key column identifier.
func (s *userPublicFieldsRepoFields) PK() exp.IdentifierExpression {
	return s.Id
}

// Connect connects to database instance.
// Must be called after NewUserPublicFieldsRepo and before any repo methods.
func (s *UserPublicFieldsRepo) Connect(wait time.Duration) error {

	if s.db == nil {
		db, err := sqlx.Open(s.dialectName, s.dsn)
		if err != nil {
			return err
		}
		s.db = db
	}

	pCtx, pCancel := context.WithTimeout(context.Background(), wait)
	defer pCancel()

	err := s.db.PingContext(pCtx)
	if err != nil {
		return fmt.Errorf("ping error: %w", err)
	}

	if v, ok := s.options.CtxTran.(*StdCtxTran); ok && v.DB == nil {
		v.DB = s.db
	}

	return nil
}

// SetMaxIdleConns sets the maximum number of connections in the idle
// connection pool.
//
// Note: can helps with stale connections if set (ex: 1 minute).
//
// See also: sql.SetMaxIdleConns.
func (s *UserPublicFieldsRepo) SetMaxIdleConns(n int) {
	s.db.SetMaxIdleConns(n)
}

// SetMaxOpenConns sets the maximum number of open connections to the database.
//
// See also: sql.SetMaxOpenConns.
func (s *UserPublicFieldsRepo) SetMaxOpenConns(n int) {
	s.db.SetMaxOpenConns(n)
}

// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
//
// See also: sql.SetConnMaxLifetime.
func (s *UserPublicFieldsRepo) SetConnMaxLifetime(d time.Duration) {
	s.db.SetConnMaxLifetime(d)
}

// WithTran wraps function call in transaction.
func (s *UserPublicFieldsRepo) WithTran(ctx context.Context, f func(ctx context.Context) error) error {

	return Transaction(ctx, s.db, s.options.CtxTran, f)
}

// Each query must executed within transaction. This method gets
// transaction from context, so exists transaction can be used.
func (s *UserPublicFieldsRepo) txFromContext(ctx context.Context) (*sqlx.Tx, error) {

	return s.options.CtxTran.TxFromContext(ctx)
}

// _Create creates a new row in database by specified model.
//
// If model have "auto" primary key field - it's will be updated in-place.
func (s *UserPublicFieldsRepo) _Create(ctx context.Context, m *UserPublicFields) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Insert(s.t).Rows(m).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("tx: exec: %w", err)
	}
	_ = res

	return nil
}

// iter iterates other select.
//
// Can be used in your custom query methods.
//
// Filters, limit or order can be set via opts.
func (s *UserPublicFieldsRepo) iter(
	ctx context.Context,
	fn func(m UserPublicFields) error,
	opt ...Option,
) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.From(s.t).Prepared(true)

	for _, o := range opt {
		o(ds)
	}

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	sigCtx, sigCtxCancel := context.WithCancel(ctx)
	defer sigCtxCancel()

	rows, err := tx.QueryxContext(sigCtx, q, args...)
	if err != nil {
		return fmt.Errorf("tx: query rows: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	for rows.Next() {
		var m UserPublicFields

		err = ctx.Err()
		if err != nil {
			return fmt.Errorf("rows: next: %w", err)
		}

		err = rows.StructScan(&m)
		if err != nil {
			return fmt.Errorf("rows struct scan: %w", err)
		}

		err = fn(m)
		if err != nil {
			sigCtxCancel()
			return fmt.Errorf("fn call: %w", err)
		}
	}

	return nil
}

// iterPrimaryKeys iterates other select with specified filter(s).
//
// Can be used in your custom query methods.
//
// Filters, limit or order can be set via opts.
func (s *UserPublicFieldsRepo) iterPrimaryKeys(
	ctx context.Context,
	fn func(pk interface{}) error,
	opt ...Option,
) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.From(s.t).Prepared(true).Select(s.f.PK())

	for _, o := range opt {
		o(ds)
	}

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	sigCtx, sigCtxCancel := context.WithCancel(ctx)
	defer sigCtxCancel()

	rows, err := tx.QueryxContext(sigCtx, q, args...)
	if err != nil {
		return fmt.Errorf("tx: query rows: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	for rows.Next() {
		var pk interface{}

		err = ctx.Err()
		if err != nil {
			return fmt.Errorf("rows: next: %w", err)
		}

		err = rows.Scan(&pk)
		if err != nil {
			return fmt.Errorf("row scan: %w", err)
		}

		err = fn(pk)
		if err != nil {
			sigCtxCancel()
			_ = rows.Close()
			return fmt.Errorf("fn call: %w", err)
		}
	}

	return nil
}

// _Get gets model from database.
//
// Note: returns (nil, nil) if row not found.
//
// See also: _GetForUpdate.
func (s *UserPublicFieldsRepo) _Get(ctx context.Context, id uuid.UUID) (*UserPublicFields, error) {

	var r *UserPublicFields

	opts := []Option{
		WithFilter(s.f.PK().Eq(id)),
	}

	err := s.iter(
		ctx,
		func(m UserPublicFields) error {
			// note: expected to be called once.
			r = &m
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return r, nil
}

// _GetForUpdate gets model from database for update (i.e. locks row).
//
// Note: returns (nil, nil) if row not found.
//
// See also: _Get.
func (s *UserPublicFieldsRepo) _GetForUpdate(ctx context.Context, id uuid.UUID) (*UserPublicFields, error) {

	var r *UserPublicFields

	opts := []Option{
		WithFilter(s.f.PK().Eq(id)),
		WithLockForUpdate(),
	}

	err := s.iter(
		ctx,
		func(m UserPublicFields) error {
			// note: expected to be called once.
			r = &m
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return r, nil
}

// _GetMany gets models from database.
//
// See also: _GetManyForUpdate.
func (s *UserPublicFieldsRepo) _GetMany(ctx context.Context, ids []uuid.UUID) ([]UserPublicFields, error) {

	items := make([]UserPublicFields, 0, len(ids))

	opts := []Option{
		WithFilter(s.f.PK().In(ids)),
	}

	err := s.iter(
		ctx,
		func(m UserPublicFields) error {
			items = append(items, m)
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return items, nil
}

// _GetManyForUpdate gets models from database for update (i.e. locks rows).
//
// See also: _GetMany.
func (s *UserPublicFieldsRepo) _GetManyForUpdate(ctx context.Context, ids []uuid.UUID) ([]UserPublicFields, error) {

	items := make([]UserPublicFields, 0, len(ids))

	opts := []Option{
		WithFilter(s.f.PK().In(ids)),
		WithLockForUpdate(),
	}

	err := s.iter(
		ctx,
		func(m UserPublicFields) error {
			items = append(items, m)
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return items, nil
}

// _Update updates database row by model.
func (s *UserPublicFieldsRepo) _Update(ctx context.Context, m UserPublicFields) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Update(s.t).
		Prepared(true).
		Set(m).
		Where(s.f.PK().Eq(m.Id))

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder: to sql: %w", err)
	}

	_, err = tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("tx: exec: %w", err)
	}

	return nil
}

// _Delete deletes row by id.
//
// Note: returns amount of deleted rows (expected to be max of 1).
//
// See also: _DeleteMany.
func (s *UserPublicFieldsRepo) _Delete(ctx context.Context, id uuid.UUID) (n int64, err error) {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().Eq(id)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder: to sql: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("tx: exec query: %w", err)
	}

	return res.RowsAffected()
}

// _DeleteMany deletes rows by ids.
//
// Warning: be careful with large ids arg.
//
// Note: returns amount of deleted rows.
//
// See also: _Delete.
func (s *UserPublicFieldsRepo) _DeleteMany(ctx context.Context, ids []uuid.UUID) (n int64, err error) {

	if len(ids) == 0 {
		// noop
		return 0, nil
	}

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().In(ids)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder: to sql: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("tx: exec: %w", err)
	}

	return res.RowsAffected()
}

// Code generated by generator; DO NOT EDIT.

package model

import (
	"context"
	"fmt"
	"github.com/doug-martin/goqu/v9"
	_ "github.com/doug-martin/goqu/v9/dialect/mysql" // import is need for proper dialect selection
	"github.com/doug-martin/goqu/v9/exp"
	. "github.com/funvit/goqu-crud-gen"
	"github.com/jmoiron/sqlx"
	"time"
)

type (
	// UserRepo implements repository for User.
	UserRepo struct {
		dsn         string
		db          *sqlx.DB
		dialect     goqu.DialectWrapper
		dialectName string
		options     RepositoryOpt

		// Short for "table".
		t string
		// Short for "table fields", holds repository model fields as goqu exp.IdentifierExpression.
		f userRepoFields
		// Short for "table columns", holds repository model columns as string.
		//
		// Helps to write goqu.UpdateDataset with goqu.Record{}.
		c userRepoColumns
	}
	userRepoFields struct {
		Id    exp.IdentifierExpression
		Name  exp.IdentifierExpression
		Email exp.IdentifierExpression
	}
	userRepoColumns struct {
		Id    string
		Name  string
		Email string
	}
)

// NewUserRepo returns a new UserRepo.
//
// Note: do not forget to set max open connections and max lifetime.
func NewUserRepo(dsn string, opt ...RepositoryOption) *UserRepo {
	const t = "user"

	s := &UserRepo{
		dsn:         dsn,
		dialect:     goqu.Dialect("mysql"),
		dialectName: "mysql",
		t:           t,
		f: userRepoFields{
			Id:    goqu.C("id").Table(t),
			Name:  goqu.C("name").Table(t),
			Email: goqu.C("email").Table(t),
		},
		c: userRepoColumns{
			Id:    "id",
			Name:  "name",
			Email: "email",
		},
	}
	s.options.CtxTran = &StdCtxTran{
		DB: s.db,
	}

	for _, o := range opt {
		o(&s.options)
	}

	return s
}

// UserRepoWithInstance returns a new UserRepo with specified sqlx.DB instance.
func UserRepoWithInstance(inst *sqlx.DB, opt ...RepositoryOption) *UserRepo {

	const t = "user"

	s := &UserRepo{
		dsn:         "",
		db:          inst,
		dialect:     goqu.Dialect("mysql"),
		dialectName: "mysql",
		t:           t,
		f: userRepoFields{
			Id:    goqu.C("id").Table(t),
			Name:  goqu.C("name").Table(t),
			Email: goqu.C("email").Table(t),
		},
		c: userRepoColumns{
			Id:    "id",
			Name:  "name",
			Email: "email",
		},
	}
	s.options.CtxTran = &StdCtxTran{
		DB: s.db,
	}

	for _, o := range opt {
		o(&s.options)
	}

	return s
}

// PK returns primary key column identifier.
func (s *userRepoFields) PK() exp.IdentifierExpression {
	return s.Id
}

// Connect connects to database instance.
// Must be called after NewUserRepo and before any repo methods.
func (s *UserRepo) Connect(wait time.Duration) error {

	if s.dsn != "" {
		db, err := sqlx.Open(s.dialectName, s.dsn)
		if err != nil {
			return err
		}
		s.db = db
	}

	pCtx, pCancel := context.WithTimeout(context.Background(), wait)
	defer pCancel()

	err := s.db.PingContext(pCtx)
	if err != nil {
		return fmt.Errorf("ping error: %w", err)
	}

	if v, ok := s.options.CtxTran.(*StdCtxTran); ok && v.DB == nil {
		v.DB = s.db
	}

	return nil
}

// SetMaxIdleConns sets the maximum number of connections in the idle
// connection pool.
//
// Note: can helps with stale connections if set (ex: 1 minute).
//
// See also: sql.SetMaxIdleConns.
func (s *UserRepo) SetMaxIdleConns(n int) {
	s.db.SetMaxIdleConns(n)
}

// SetMaxOpenConns sets the maximum number of open connections to the database.
//
// See also: sql.SetMaxOpenConns.
func (s *UserRepo) SetMaxOpenConns(n int) {
	s.db.SetMaxOpenConns(n)
}

// SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
//
// See also: sql.SetConnMaxLifetime.
func (s *UserRepo) SetConnMaxLifetime(d time.Duration) {
	s.db.SetConnMaxLifetime(d)
}

// WithTran wraps function call in transaction.
func (s *UserRepo) WithTran(ctx context.Context, f func(ctx context.Context) error) error {

	return Transaction(ctx, s.db, s.options.CtxTran, f)
}

// Each query must executed within transaction. This method gets
// transaction from context, so exists transaction can be used.
func (s *UserRepo) txFromContext(ctx context.Context) (*sqlx.Tx, error) {

	return s.options.CtxTran.TxFromContext(ctx)
}

// Create creates a new row in database by specified model.
//
// If model have "auto" primary key field - it's will be updated in-place.
func (s *UserRepo) Create(ctx context.Context, m *User) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Insert(s.t).Rows(m).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder error: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("insert query error: %w", err)
	}
	_ = res

	m.Id, err = res.LastInsertId()
	if err != nil {
		return fmt.Errorf("auto id get error: %w", err)
	}

	return nil
}

// iter iterates other select.
//
// Can be used in your custom query methods.
//
// Filters, limit or order can be set via opts.
func (s *UserRepo) iter(
	ctx context.Context,
	fn func(m User) error,
	opt ...Option,
) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.From(s.t).Prepared(true)

	for _, o := range opt {
		o(ds)
	}

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder error: %w", err)
	}

	sigCtx, sigCtxCancel := context.WithCancel(ctx)
	defer sigCtxCancel()

	rows, err := tx.QueryxContext(ctx, q, args...)
	if err != nil {
		return fmt.Errorf("select query error: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	for rows.Next() {
		var m User
		select {
		case <-sigCtx.Done():
			_ = rows.Close()
			return context.Canceled
		default:
		}

		err = rows.StructScan(&m)
		if err != nil {
			return fmt.Errorf("row scan error: %w", err)
		}

		err = fn(m)
		if err != nil {
			sigCtxCancel()
			_ = rows.Close()
			return fmt.Errorf("fn call: %w", err)
		}
	}

	return nil
}

// iterPrimaryKeys iterates other select with specified filter(s).
//
// Can be used in your custom query methods.
//
// Filters, limit or order can be set via opts.
func (s *UserRepo) iterPrimaryKeys(
	ctx context.Context,
	fn func(pk interface{}) error,
	opt ...Option,
) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.From(s.t).Prepared(true).Select(s.f.PK())

	for _, o := range opt {
		o(ds)
	}

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder error: %w", err)
	}

	sigCtx, sigCtxCancel := context.WithCancel(ctx)
	defer sigCtxCancel()

	rows, err := tx.QueryxContext(ctx, q, args...)
	if err != nil {
		return fmt.Errorf("select query error: %w", err)
	}
	defer func() {
		_ = rows.Close()
	}()

	for rows.Next() {
		var pk interface{}
		select {
		case <-sigCtx.Done():
			_ = rows.Close()
			return context.Canceled
		default:
		}

		err = rows.Scan(&pk)
		if err != nil {
			return fmt.Errorf("row scan error: %w", err)
		}

		err = fn(pk)
		if err != nil {
			sigCtxCancel()
			_ = rows.Close()
			return fmt.Errorf("fn call: %w", err)
		}
	}

	return nil
}

// Get gets model from database.
//
// Note: returns (nil, nil) if row not found.
//
// See also: GetForUpdate.
func (s *UserRepo) Get(ctx context.Context, id int64) (*User, error) {

	var r *User

	opts := []Option{
		WithFilter(s.f.PK().Eq(id)),
	}

	err := s.iter(
		ctx,
		func(m User) error {
			// note: expected to be called once.
			r = &m
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return r, nil
}

// GetForUpdate gets model from database for update (i.e. locks row).
//
// Note: returns (nil, nil) if row not found.
//
// See also: Get.
func (s *UserRepo) GetForUpdate(ctx context.Context, id int64) (*User, error) {

	var r *User

	opts := []Option{
		WithFilter(s.f.PK().Eq(id)),
		WithLockForUpdate(),
	}

	err := s.iter(
		ctx,
		func(m User) error {
			// note: expected to be called once.
			r = &m
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return r, nil
}

// GetMany gets models from database.
//
// See also: GetManyForUpdate.
func (s *UserRepo) GetMany(ctx context.Context, ids []int64) ([]User, error) {

	items := make([]User, 0, len(ids))

	opts := []Option{
		WithFilter(s.f.PK().In(ids)),
	}

	err := s.iter(
		ctx,
		func(m User) error {
			items = append(items, m)
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return items, nil
}

// GetManyForUpdate gets models from database for update (i.e. locks rows).
//
// See also: GetMany.
func (s *UserRepo) GetManyForUpdate(ctx context.Context, ids []int64) ([]User, error) {

	items := make([]User, 0, len(ids))

	opts := []Option{
		WithFilter(s.f.PK().In(ids)),
		WithLockForUpdate(),
	}

	err := s.iter(
		ctx,
		func(m User) error {
			items = append(items, m)
			return nil
		},
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return items, nil
}

// Update updates database row by model.
func (s *UserRepo) Update(ctx context.Context, m User) error {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return err
	}

	ds := s.dialect.Update(s.t).
		Prepared(true).
		Set(m).
		Where(s.f.PK().Eq(m.Id))

	q, args, err := ds.ToSQL()
	if err != nil {
		return fmt.Errorf("query builder error: %w", err)
	}

	_, err = tx.Exec(q, args...)
	if err != nil {
		return fmt.Errorf("update query error: %w", err)
	}

	return nil
}

// Delete deletes row by id.
//
// Note: returns amount of deleted rows (expected to be max of 1).
//
// See also: DeleteMany.
func (s *UserRepo) Delete(ctx context.Context, id int64) (n int64, err error) {

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().Eq(id)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder error: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("delete query error: %w", err)
	}

	return res.RowsAffected()
}

// DeleteMany deletes rows by ids.
//
// Warning: be careful with large ids arg.
//
// Note: returns amount of deleted rows.
//
// See also: Delete.
func (s *UserRepo) DeleteMany(ctx context.Context, ids []int64) (n int64, err error) {

	if len(ids) == 0 {
		// noop
		return 0, nil
	}

	tx, err := s.txFromContext(ctx)
	if err != nil {
		return 0, err
	}

	ds := s.dialect.Delete(s.t).Where(s.f.PK().In(ids)).Prepared(true)

	q, args, err := ds.ToSQL()
	if err != nil {
		return 0, fmt.Errorf("query builder error: %w", err)
	}

	res, err := tx.Exec(q, args...)
	if err != nil {
		return 0, fmt.Errorf("delete query error: %w", err)
	}

	return res.RowsAffected()
}
